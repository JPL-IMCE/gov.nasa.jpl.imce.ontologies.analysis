#    $HeadURL$
#
#    $LastChangedRevision$
#    $LastChangedDate$
#
#    $LastChangedBy$
#
#    Copyright (c) 2009,2010 California Institute of Technology.
#    All rights reserved.
#

ARTIFACTS_DIR ?= <%= ARTIFACTS_DIR = ENV['ARTIFACTS_DIR'] || 'artifacts' %>
AUDITS_DIR ?= tests/audits
AUDITS_TREE ?= $(AUDITS_TREE_PATH)
AUDITS_TEST_FILE ?= $(AUDITS_DIR)/run-audits$(XML_SUFFIX)

BACKBONE_DISJOINTS ?= Entity ReifiedObjectProperty ReifiedStructuredDataProperty StructuredDatatype
BACKBONE_PREFIX ?= http://imce.jpl.nasa.gov/backbone

BUNDLES_DIR ?= $(ARTIFACTS_DIR)/bundles
BUNDLE_CLOSURE_PROJECT ?= europa
BUNDLE_CLOSURE_STEM ?= export-bundle

CLOSE_BUNDLE ?= $(JRUBY_CMD) $(TOOLS)/tools/close-bundle
CLOSE_BUNDLE_OPTS ?= --export --iri-file $(CLOSE_BUNDLE_IRI_FILE)
CLOSE_BUNDLE_IRI_FILE ?= <%= CLOSE_BUNDLE_IRI_FILE = ENV['CLOSE_BUNDLE_IRI_FILE'] || ARTIFACTS_DIR + '/close_bundle_iris' %>

DEPENDENCIES_FILE ?= .dependencies

ENTAIL ?= $(JRUBY_CMD) $(TOOLS_DIR)/entail
ENTAIL_OPTS = --remove-backbone

EMPTY_IMPORTS_FILE ?= empty-imports.yaml

ENTAILMENTS_DIR ?= $(ARTIFACTS_DIR)/entailments

EXTRACT ?= $(JRUBY_CMD) $(TOOLS_DIR)/extract-ontology
EXTRACT_OPTS ?= --host $(JENA_HOST) --port $(JENA_PORT) --dataset $(JENA_DATASET)

FUSEKI_S_DELETE ?= $(FUSEKI_BIN)/s-delete
FUSEKI_S_GET ?= $(FUSEKI_BIN)/s-get
FUSEKI_S_PUT ?= $(FUSEKI_BIN)/s-put

GET_UNSATS ?= $(TOOLS_DIR)/get-unsats
GET_UNSAT_PROPS_OPTS ?= --get-props
GET_UNSAT_PROP_SOURCES_OPTS ?= --get-prop-sources
GET_UNSAT_PROP_TARGETS_OPTS ?= --get-prop-targets
GET_UNSAT_SUPS_OPTS ?= --get-sups
GET_UNSAT_FUNC_PROPS_OPTS ?= --get-func-props
GET_UNSAT_IRIS_OPTS ?= 

GET_UNSAT_ROOTS ?= $(TOOLS_DIR)/get-unsat-roots
GET_UNSAT_ROOTS_OPTS ?= --info

IRI_TO_MDID ?= $(TOOLS_DIR)/iri-to-mdid
IRI_TO_MDID_OPTS ?=

JRUBY ?= jruby
JRUBY_CMD ?= $(JRUBY) $(JRUBY_OPTS)
JRUBY_OPTS ?= --headless -J-Xmx16384m -J-Djava.util.logging.config.file=logging.properties

LOAD_REPO ?= $(TOOLS_DIR)/load-jena
LOAD_REPO_OPTS ?= --host $(JENA_HOST) --port $(JENA_PORT) --dataset $(JENA_DATASET)

LOCATION_MAPPING_FILE ?= location-mapping.yaml

MAKE_MAKEFILE ?= $(TOOLS_DIR)/make-makefile

OMG_ORG ?= <%= OMG_ORG = 'www.omg.org' %>
ONTOLOGIES_DIR ?= <%= ONTOLOGIES_DIR = ENV['ONTOLOGIES_DIR'] || ARTIFACTS_DIR + '/ontologies' %>
OWL_SUFFIX = .owl

REPORTS_DIR ?= $(ARTIFACTS_DIR)/reports
REPORTS_TREE ?= $(REPORTS_TREE_PATH)
REPORTS_TEST_FILE ?= $(REPORTS_DIR)/run-reports$(ZIP_SUFFIX)
RUBY ?= $(JRUBY)
RUN_AUDITS ?= $(JRUBY_CMD) $(TOOLS_DIR)/run-audits-jena
RUN_AUDITS_OPTS ?= --info --host $(JENA_HOST) --port $(JENA_PORT) --dataset $(JENA_DATASET) --iri-file $(RUN_AUDITS_IRI_FILE)
RUN_AUDITS_IRI_FILE ?= <%= RUN_AUDITS_IRI_FILE = ENV['RUN_AUDITS_IRI_FILE'] || ARTIFACTS_DIR + '/run_audits_iris' %>
RUN_REPORTS ?= $(RUN_AUDITS)
RUN_REPORTS_OPTS ?= --info --report --host $(JENA_HOST) --port $(JENA_PORT) --dataset $(JENA_DATASET) --iri-file $(RUN_REPORTS_IRI_FILE)
RUN_REPORTS_IRI_FILE ?= $(ARTIFACTS_DIR)/run_reports_iris
RUN_REPORTS_IRI_FILE ?= <%= RUN_REPORTS_IRI_FILE = ENV['RUN_REPORTS_IRI_FILE'] || ARTIFACTS_DIR + '/run_reports_iris' %>

SENTINELS_DIR ?= $(ARTIFACTS_DIR)/.sentinels

TESTS_DIR ?= tests/consistency
TOOLS_DIR ?= $(TOOLS)/tools

UNSATS_REPORT_FILE ?= tests/consistency/unsats.csv
UNSAT_PROPS_REPORT_FILE ?= tests/consistency/unsat-props.csv
UNSAT_PROP_SOURCES_REPORT_FILE ?= tests/consistency/unsat-prop-sources.csv
UNSAT_PROP_TARGETS_REPORT_FILE ?= tests/consistency/unsat-prop-targets.csv
UNSAT_SUPS_REPORT_FILE ?= tests/consistency/unsat-sups.csv
UNSAT_FUNC_PROPS_REPORT_FILE = tests/consistency/unsat-func-props.csv

UNSAT_ROOTS_REPORT_FILE = tests/consistency/unsat-roots.csv

VALIDATE_OWL ?= $(JRUBY_CMD) -J-Djava.util.logging.config.file=logging.properties $(TOOLS_DIR)/validate-owl
VALIDATE_OWL_OPTS ?= --info --satisfiability

VALIDATE_ROOTS_TEST_FILE ?= $(TESTS_DIR)/validate-roots$(XML_SUFFIX)
VALIDATE_ROOTS_ID ?= validate-roots

VIEW_STEM ?= imce.jpl.nasa.gov/view/

VOCABULARY_BUNDLE_IRI ?= <%= VOCABULARY_BUNDLE_IRI = 'http://imce.jpl.nasa.gov/discipline/fse/fse-bundle' %>

XML_SUFFIX ?= .xml

ZIP_SUFFIX ?= .zip

tmpfile = $(dir $1).$(notdir $1)

-include $(DEPENDENCIES_FILE)

# 
# load ontology metadata
#

<%

  class OMFGraph
    def initialize(iri, stem, open, o_dir)
      @iri = iri
      @stem = stem
      @open = open
      @o_dir = o_dir
    end
    def ontology_iri
      @iri
    end
    def entailments_iri(type)
      "#{@iri}/#{type}"
    end
    attr_reader :open
    def ontology_file
      "#{@o_dir}/#{@stem}$(OWL_SUFFIX)"
    end
    def ontology_file_iri
      'file://' + ontology_file
    end
    def entailments_file(type)
      "$(ENTAILMENTS_DIR)/#{@stem}/#{type}$(OWL_SUFFIX)"
    end
    def entailments_file_iri(type)
      'file://' + entailments_file(type)
    end
    def ontology_sentinel
      "$(SENTINELS_DIR)/#{@stem}$(OWL_SUFFIX)"
    end
    def entailments_sentinel(type)
      "$(SENTINELS_DIR)/#{@stem}/#{type}$(OWL_SUFFIX)"
    end
  end
  class OMFOntologyGraph < OMFGraph
    def initialize(iri, stem, open)
      super(iri, stem, open, '$(ONTOLOGIES_DIR)')
    end
  end
  class OMFBundleGraph < OMFGraph
    def initialize(stem, project)
      @stem = stem
      @project = project
      super(ontology_iri, stem, false, '$(BUNDLES_DIR)')
    end
    def ontology_iri
      'http://' + path
    end
    def abbrev
      @stem
    end
    def name
      @stem
    end
    def path
      "imce.jpl.nasa.gov/project/#{@project}/#{@stem}"
    end
    def backbone_iri
      "$(BACKBONE_PREFIX)/#{path}"
    end
    def backbone_abbrev
      @stem + '-backbone'
    end
  end

  require 'fileutils'
  require 'find'
  require 'json'
  require 'jgrapht-core-0.9.0.jar'
  require 'rexml/document'
  require 'shellwords'

  java_import 'org.jgrapht.experimental.dag.DirectedAcyclicGraph'
  java_import 'org.jgrapht.graph.DefaultEdge'
  java_import 'org.jgrapht.alg.TransitiveClosure'

  # Constants.
  
  ENTAILMENTS = {
	'ClassEntailments' => %w{ AllSubclass },
	'PropertyEntailments' => %w{ InverseProperty AllSubproperty }
  }

  # Traverse ontologies and mine metadata.

  metadata = Hash.new { |h, k| h[k] = [] }
  FileUtils.cd(ONTOLOGIES_DIR) do
    Find.find('.') do |path|
      Find.prune if File.basename(path) =~ Regexp.new(OMG_ORG)
      next unless File.file?(path) && File.basename(path) =~ /\.owl\z/
      next if File.basename(path) =~ /-embedding\.owl/

      iports = nil
      File.open(path) do |f|
	doc = REXML::Document.new(f)

	ontology = doc.root.get_elements('owl:Ontology').first
	raise "no ontology for #{path}" unless ontology
	iri = ontology.attributes['rdf:about']
	raise "no iri for #{path}" unless iri
	begin
	  open_attrs = ontology.get_elements('oml:isOMLTerminologyBoxOpen').flat_map { |o| o.get_text.value }
	rescue
	  raise "error in open attribute for #{path}"
	end
	begin
	  imports = ontology.get_elements('owl:imports').flat_map { |i| i.attributes['rdf:resource'] }
	rescue
	  raise "error in imports for #{path}"
	end
	is_open = open_attrs.any? { |o| o == 'true' }

	stem = "#{File.dirname(path)}/#{File.basename(path, '.owl')}"
	metadata['nodes'] << { 'iri' => iri, 'stem' => stem, 'open' => is_open }

	imports.each do |imported|
	  metadata['edges'] << { 'importing' => iri, 'imported' => imported }
	end
      end
    end
  end

  # Create graph structures.

  graphs = metadata['nodes'].inject({}) do |m, n|
    m[n['iri']] = OMFOntologyGraph.new(n['iri'], n['stem'], n['open'])
    m
  end

  # Add graph for export bundle.
  
  bundle_closure_graph = OMFBundleGraph.new('$(BUNDLE_CLOSURE_STEM)', '$(BUNDLE_CLOSURE_PROJECT)')
  graphs[bundle_closure_graph.ontology_iri] = bundle_closure_graph
  
  # Find exported terminology graphs.
  
  exported_graphs = graphs.values.reject { |g| g.open }
  warn "#{exported_graphs.length} exported graphs"
 
  # Find imported terminology graphs.
  
  imported_graphs = graphs.values.select { |g| g.open }
  warn "#{imported_graphs.length} imported graphs"
 
  # Set file prefixes and suffixes.
  
  all_graphs = exported_graphs + imported_graphs
    
  # Create location mapping.
  
  location_map = graphs.values.inject({}) do |m, g|
    m[g.ontology_iri] = g.ontology_file_iri
    m
  end
  location_map[bundle_closure_graph.ontology_iri] = bundle_closure_graph.ontology_file_iri
  								
  # Create imports graph. Omit back edges; processing does not rely on acyclicity at present.
  
  imports_graph = metadata['edges'].inject(DirectedAcyclicGraph.new(DefaultEdge)) do |memo, edge|
    importing = graphs[edge['importing']]
    raise "no importing graph for #{edge['importing']}" unless importing
    imported = graphs[edge['imported']]
    raise "no imported graph for #{edge['imported']}" unless imported
    memo.addVertex(importing)
    memo.addVertex(imported)
    begin
      memo.addEdge(importing, imported)
    rescue Java::JavaLang::IllegalArgumentException
      warn "back edge omitted"
    end
    memo
  end

  # Find root nodes of imports graph that correspond to exported packages.
  
  ig = imports_graph.dup
  TransitiveClosure::INSTANCE.closeSimpleDirectedGraph(ig)
  root_nodes = ig.vertexSet.select do |node|
    ig.inDegreeOf(node) == 0 &&
    exported_graphs.include?(node)
  end
  warn "#{root_nodes.length} root graphs"

  # Create imports relationships for export bundle

  raise "bad vertex #{bundle_closure_graph.inspect}" unless OMFBundleGraph === bundle_closure_graph
  imports_graph.addVertex(bundle_closure_graph)
  root_nodes.each do |node|
    raise "bad edge target #{node.inspect}" unless OMFGraph === node
    imports_graph.addEdge(bundle_closure_graph, node)
  end
  
  # Form transitive closure of imports_graph.
  
  TransitiveClosure::INSTANCE.closeSimpleDirectedGraph(imports_graph)
												      
  # Create imports map.
									
  imports_map = Hash.new { |h, k| h[k] = Set.new }
  iter = imports_graph.iterator
  while iter.hasNext
    source = iter.next
    raise "bad source #{source.inspect}" unless OMFGraph === source
    imports_map[source] = imports_graph.edgesOf(source).map do |e|
      imports_graph.getEdgeTarget(e)
    end.reject do |target|
      target == source
    end
    bad = imports_map[source].reject { |i| OMFGraph === i }
    raise "bad imports for #{source.ontology_iri}: #{bad.inspect}" unless bad.empty?
  end

  # Create rules for creating bundle closure.
 
  bundle_closure_file_rule = Makefile::Rule.new(bundle_closure_graph.ontology_file)
  
  iris = root_nodes.map { |o| o.ontology_iri }
  files = root_nodes.map { |o| o.ontology_file }
  
  vocabulary_bundle_graph = graphs[VOCABULARY_BUNDLE_IRI]
  raise "no graph for #{VOCABULARY_BUNDLE_IRI}" unless vocabulary_bundle_graph
  iris << vocabulary_bundle_graph.ontology_iri
  files << vocabulary_bundle_graph.ontology_file

  File.open(CLOSE_BUNDLE_IRI_FILE, 'w') { |f| f.write(iris.join("\n")) }
  
  bundle_closure_file_rule.prereqs += files 
  bundle_closure_file_rule.cmds << "$(call do_closure,#{bundle_closure_graph.name},#{bundle_closure_graph.ontology_iri}," +
                                   "#{bundle_closure_graph.abbrev},#{bundle_closure_graph.backbone_iri}," +
				   "#{bundle_closure_graph.backbone_abbrev})"
  
  # Create rules for validating root ontologies.
 
  validate_roots_test_file_rule = Makefile::Rule.new('$(VALIDATE_ROOTS_TEST_FILE)')
  validate_roots_test_file_rule.prereqs << bundle_closure_graph.ontology_file
  validate_roots_test_file_rule.cmds << "$(call validate_roots,$(VALIDATE_ROOTS_ID),#{bundle_closure_graph.ontology_iri})"
  
  # Create rules for calculating entailments.
  
  entailments_top_rule = Makefile::Rule.new('entailments')
  entailments_rules = [entailments_top_rule]
  ENTAILMENTS.each do |type, data|
    [bundle_closure_graph].each do |o|
      input_iri = o.ontology_iri
      output_iri = o.entailments_iri(type)
      target = o.entailments_file(type)
      entailments_top_rule.prereqs << target
      rule = Makefile::Rule.new(target)
      rule.prereqs << o.ontology_file
      entailments_rules << rule
      rule.cmds << %Q{$(call do_entailments,#{input_iri},#{output_iri},"#{data.join(' ')}")}
    end
  end
  
%>

#
# location mapping file
#
# The location mapping file is a YAML file that maps ontology IRIs to file IRIs. It is used by the OWL
# API for ontology loading and retrieval.
#

.PHONY:	location-mapping

location-mapping: $(LOCATION_MAPPING_FILE)

<%=
  rule = Makefile::Rule.new('$(LOCATION_MAPPING_FILE)')
  rule.prereqs << 'Makefile'
  rule.cmds << "@echo '->' $@"
  rule.cmds << '@ > $@'
  rule.cmds += location_map.to_yaml.each_line.inject([]) { |m, o| m << "@echo '#{o.strip}' >> $@"; m }
  rule
%>

#
# validate-roots
#

define validate_roots
  @echo validate '->' $@
  @mkdir -p $(dir $@)
  @$(VALIDATE_OWL) $(VALIDATE_OWL_OPTS) --id $(1) $(2) > $@
endef

.PHONY: validate-roots

validate-roots:	$(VALIDATE_ROOTS_TEST_FILE)

<%= validate_roots_test_file_rule %>

#
# entailments
#

.PHONY:	entailments

define do_entailments
  @echo entail '->' $@
  @mkdir -p $(dir $@)
  @$(ENTAIL) $(ENTAIL_OPTS) \
  	     $$(test $$(grep '<failure' $(VALIDATE_ROOTS_TEST_FILE) | wc -l) -gt 0 && echo '--vacuous') \
  	     --input-iri $(1) --output-iri $(2) --types $(3) $(4) $^ > $(call tmpfile,$@) && mv $(call tmpfile,$@) $@
endef

<%= entailments_rules.map { |r| r.to_s }.join("\n") %>

#
# load-production
#

#
# FUSEKI_ENDPOINT must be the URL of the Fuseki repository endpoint.
# http://[host]:[port] or https://[host]:[port]
#
define do_load
  @echo load $(2) '->' $(1)
  @mkdir -p $(dir $@)
  curl -v \
    -X PUT \
    -H "Content-Type: application/rdf+xml" \
    -G '$(FUSEKI_ENDPOINT)/$(JENA_DATASET)/data' \
    --data-urlencode '$(1)' \
    -T '$(2)' && touch $@
endef

load-production:	load-ontologies-production

.PHONY: load-ontologies-production

<%=
  rule = Rule.new('load-ontologies-production')
  graph_rules = []
  imports_map.keys.each do |g|
    rule.prereqs << g.ontology_sentinel
    graph_rules << graph_rule = Rule.new(g.ontology_sentinel)
    graph_rule.prereqs << g.ontology_file
    graph_rule.cmds << "$(call do_load,#{g.ontology_iri},#{g.ontology_file})"
  end
  rule.to_s + graph_rules.join
%>

load-production:	load-entailments-production

.PHONY: load-entailments-production

<%=
  rule = Rule.new('load-entailments-production')
  graph_rules = []
  [bundle_closure_graph].each do |g|
    ENTAILMENTS.keys.each do |type|
      rule.prereqs << g.entailments_sentinel(type)
      graph_rules << graph_rule = Rule.new(g.entailments_sentinel(type))
      graph_rule.prereqs << g.entailments_file(type)
      graph_rule.cmds << "$(call do_load,#{g.entailments_iri(type)},#{g.entailments_file(type)})"
    end
  end
  rule.to_s + graph_rules.join
%>

#
# run-audits
#

.PHONY: run-audits

run-audits:	$(AUDITS_TEST_FILE)

define do_audit
  @echo audit '->' $@
  @mkdir -p $(dir $@)
  @$(RUN_AUDITS) $(RUN_AUDITS_OPTS) $(1) > $(call tmpfile,$@) && mv $(call tmpfile,$@) $@
endef

<%=
  rule = Rule.new('$(AUDITS_TEST_FILE)')
  iris = exported_graphs.map { |g| g.ontology_iri }
  File.open(RUN_AUDITS_IRI_FILE, 'w') { |f| f.write(iris.join("\n")) }
  rule.prereqs << bundle_closure_graph.ontology_sentinel
  rule.prereqs += imports_map[bundle_closure_graph].map { |i| i.ontology_sentinel }
  rule.prereqs += ENTAILMENTS.keys.map { |type| bundle_closure_graph.entailments_sentinel(type) }
  rule.cmds << "$(call do_audit,--audit-tree $(AUDITS_TREE))"
  rule
%>

#
# run-reports
#

.PHONY: run-reports

run-reports:	$(REPORTS_TEST_FILE)

define do_report
  @echo report '->' $@
  @mkdir -p $(dir $@)
  @$(RUN_REPORTS) $(RUN_REPORTS_OPTS) $(1) > $(call tmpfile,$@) && mv $(call tmpfile,$@) $@
endef

<%=
  rule = Rule.new('$(REPORTS_TEST_FILE)')
  iris = exported_graphs.map { |g| g.ontology_iri }
  File.open(RUN_REPORTS_IRI_FILE, 'w') { |f| f.write(iris.join("\n")) }
  rule.prereqs << bundle_closure_graph.ontology_sentinel
  rule.prereqs += imports_map[bundle_closure_graph].map { |i| i.ontology_sentinel }
  rule.prereqs += ENTAILMENTS.keys.map { |type| bundle_closure_graph.entailments_sentinel(type) }
  rule.cmds << "$(call do_report,--audit-tree $(REPORTS_TREE))"
  rule
%>

#
# identify-unsats
#

.PHONY: identify-unsats

define do_identify_unsats
  @echo identify-unsats '->' $@
  @$(JRUBY_CMD) $(GET_UNSATS) $(GET_UNSAT_IRIS_OPTS) $< \
  	> $(call tmpfile,$@) && mv $(call tmpfile,$@) $@
endef

identify-unsats: $(UNSATS_REPORT_FILE)

$(UNSATS_REPORT_FILE): $(VALIDATE_ROOTS_TEST_FILE)
	$(call do_identify_unsats)
	
#
# identify-unsat-props
#

.PHONY: identify-unsat-props

define do_identify_unsat_props
  @echo identify-unsat-props '->' $@
  @$(JRUBY_CMD) $(GET_UNSATS) $(GET_UNSAT_PROPS_OPTS) $< \
  	> $(call tmpfile,$@) && mv $(call tmpfile,$@) $@
endef

identify-unsat-props: $(UNSAT_PROPS_REPORT_FILE)

$(UNSAT_PROPS_REPORT_FILE): $(VALIDATE_ROOTS_TEST_FILE)
	$(call do_identify_unsat_props)
	
#
# identify-unsat-prop-sources
#

.PHONY: identify-unsat-prop-sources

define do_identify_unsat_prop_sources
  @echo identify-unsat-prop-sources '->' $@
  @$(JRUBY_CMD) $(GET_UNSATS) $(GET_UNSAT_PROP_SOURCES_OPTS) $< \
  	> $(call tmpfile,$@) && mv $(call tmpfile,$@) $@
endef

identify-unsat-prop-sources: $(UNSAT_PROP_SOURCES_REPORT_FILE)

$(UNSAT_PROP_SOURCES_REPORT_FILE): $(VALIDATE_ROOTS_TEST_FILE)
	$(call do_identify_unsat_prop_sources)
	
#
# identify-unsat-prop-targets
#

.PHONY: identify-unsat-prop-targets

define do_identify_unsat_prop_targets
  @echo identify-unsat-prop-targets '->' $@
  @$(JRUBY_CMD) $(GET_UNSATS) $(GET_UNSAT_PROP_TARGETS_OPTS) $< \
  	> $(call tmpfile,$@) && mv $(call tmpfile,$@) $@
endef

identify-unsat-prop-targets: $(UNSAT_PROP_TARGETS_REPORT_FILE)

$(UNSAT_PROP_TARGETS_REPORT_FILE): $(VALIDATE_ROOTS_TEST_FILE)
	$(call do_identify_unsat_prop_targets)
	
#
# identify-unsat-sups
#

.PHONY: identify-unsat-sups

define do_identify_unsat_sups
  @echo identify-unsat-sups '->' $@
  @$(JRUBY_CMD) $(GET_UNSATS) $(GET_UNSAT_SUPS_OPTS) $< \
  	> $(call tmpfile,$@) && mv $(call tmpfile,$@) $@
endef

identify-unsat-sups: $(UNSAT_SUPS_REPORT_FILE)

$(UNSAT_SUPS_REPORT_FILE): $(VALIDATE_ROOTS_TEST_FILE)
	$(call do_identify_unsat_sups)
	
#
# identify-unsat-roots
#

.PHONY: identify-unsat-roots

define do_identify_unsat_roots
  @echo identify-unsat-roots '->' $@
  @$(JRUBY_CMD) $(GET_UNSAT_ROOTS) $(GET_UNSAT_ROOTS_OPTS) $< \
  	> $(call tmpfile,$@) && mv $(call tmpfile,$@) $@
endef

identify-unsat-roots: $(UNSAT_ROOTS_REPORT_FILE)

$(UNSAT_ROOTS_REPORT_FILE): $(VALIDATE_ROOTS_TEST_FILE)
	$(call do_identify_unsat_roots)
	
#
# identify-unsat-func-props
#

.PHONY: identify-unsat-func-props

define do_identify_unsat_func_props
  @echo identify-unsat-func-props '->' $@
  @$(JRUBY_CMD) $(GET_UNSATS) $(GET_UNSAT_FUNC_PROPS_OPTS) $< \
  	> $(call tmpfile,$@) && mv $(call tmpfile,$@) $@
endef

identify-unsat-func-props: $(UNSAT_FUNC_PROPS_REPORT_FILE)

$(UNSAT_FUNC_PROPS_REPORT_FILE): $(VALIDATE_ROOTS_TEST_FILE)
	$(call do_identify_unsat_func_props)
	
.PHONY:	closure-artifacts

define do_closure
  @echo closure artifact '->' $@
  @mkdir -p $(dir $@)
  @$(CLOSE_BUNDLE) $(CLOSE_BUNDLE_OPTS) \
    --namespace '$(3) => $(2)' \
    --namespace '$(5) => $(4)' \
    --name $(1) --uri $(2) --backbone-disjoints "$(BACKBONE_DISJOINTS)" \
    --backbone-prefix $(BACKBONE_PREFIX) \
    > $(call tmpfile,$@) && mv $(call tmpfile,$@) $@
endef

<%= bundle_closure_file_rule %>

#
# Makefile
#

Makefile: Makefile.erb
	@make -f Makefile.bootstrap $@ ONTOLOGIES_DIR="<%= ENV['ONTOLOGIES_DIR'] %>"

#
# clean
#

.PHONY: clean

clean:
	@rm -rf $(ARTIFACTS_DIR) $(LOCATION_MAPPING_FILE) $(TESTS_DIR) $(AUDITS_DIR)
